/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/ts/services/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/rellax/rellax.js":
/*!***************************************!*\
  !*** ./node_modules/rellax/rellax.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n// ------------------------------------------\n// Rellax.js\n// Buttery smooth parallax library\n// Copyright (c) 2016 Moe Amaya (@moeamaya)\n// MIT license\n//\n// Thanks to Paraxify.js and Jaime Cabllero\n// for parallax concepts\n// ------------------------------------------\n\n(function (root, factory) {\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(typeof window !== \"undefined\" ? window : global, function () {\n  var Rellax = function(el, options){\n    \"use strict\";\n\n    var self = Object.create(Rellax.prototype);\n\n    var posY = 0;\n    var screenY = 0;\n    var posX = 0;\n    var screenX = 0;\n    var blocks = [];\n    var pause = true;\n\n    // check what requestAnimationFrame to use, and if\n    // it's not supported, use the onscroll event\n    var loop = window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      function(callback){ return setTimeout(callback, 1000 / 60); };\n\n    // store the id for later use\n    var loopId = null;\n\n    // Test via a getter in the options object to see if the passive property is accessed\n    var supportsPassive = false;\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function() {\n          supportsPassive = true;\n        }\n      });\n      window.addEventListener(\"testPassive\", null, opts);\n      window.removeEventListener(\"testPassive\", null, opts);\n    } catch (e) {}\n\n    // check what cancelAnimation method to use\n    var clearLoop = window.cancelAnimationFrame || window.mozCancelAnimationFrame || clearTimeout;\n\n    // check which transform property to use\n    var transformProp = window.transformProp || (function(){\n        var testEl = document.createElement('div');\n        if (testEl.style.transform === null) {\n          var vendors = ['Webkit', 'Moz', 'ms'];\n          for (var vendor in vendors) {\n            if (testEl.style[ vendors[vendor] + 'Transform' ] !== undefined) {\n              return vendors[vendor] + 'Transform';\n            }\n          }\n        }\n        return 'transform';\n      })();\n\n    // Default Settings\n    self.options = {\n      speed: -2,\n\t    verticalSpeed: null,\n\t    horizontalSpeed: null,\n      breakpoints: [576, 768, 1201],\n      center: false,\n      wrapper: null,\n      relativeToWrapper: false,\n      round: true,\n      vertical: true,\n      horizontal: false,\n      verticalScrollAxis: \"y\",\n      horizontalScrollAxis: \"x\",\n      callback: function() {},\n    };\n\n    // User defined options (might have more in the future)\n    if (options){\n      Object.keys(options).forEach(function(key){\n        self.options[key] = options[key];\n      });\n    }\n\n    function validateCustomBreakpoints () {\n      if (self.options.breakpoints.length === 3 && Array.isArray(self.options.breakpoints)) {\n        var isAscending = true;\n        var isNumerical = true;\n        var lastVal;\n        self.options.breakpoints.forEach(function (i) {\n          if (typeof i !== 'number') isNumerical = false;\n          if (lastVal !== null) {\n            if (i < lastVal) isAscending = false;\n          }\n          lastVal = i;\n        });\n        if (isAscending && isNumerical) return;\n      }\n      // revert defaults if set incorrectly\n      self.options.breakpoints = [576, 768, 1201];\n      console.warn(\"Rellax: You must pass an array of 3 numbers in ascending order to the breakpoints option. Defaults reverted\");\n    }\n\n    if (options && options.breakpoints) {\n      validateCustomBreakpoints();\n    }\n\n    // By default, rellax class\n    if (!el) {\n      el = '.rellax';\n    }\n\n    // check if el is a className or a node\n    var elements = typeof el === 'string' ? document.querySelectorAll(el) : [el];\n\n    // Now query selector\n    if (elements.length > 0) {\n      self.elems = elements;\n    }\n\n    // The elements don't exist\n    else {\n      console.warn(\"Rellax: The elements you're trying to select don't exist.\");\n      return;\n    }\n\n    // Has a wrapper and it exists\n    if (self.options.wrapper) {\n      if (!self.options.wrapper.nodeType) {\n        var wrapper = document.querySelector(self.options.wrapper);\n\n        if (wrapper) {\n          self.options.wrapper = wrapper;\n        } else {\n          console.warn(\"Rellax: The wrapper you're trying to use doesn't exist.\");\n          return;\n        }\n      }\n    }\n\n    // set a placeholder for the current breakpoint\n    var currentBreakpoint;\n\n    // helper to determine current breakpoint\n    var getCurrentBreakpoint = function (w) {\n      var bp = self.options.breakpoints;\n      if (w < bp[0]) return 'xs';\n      if (w >= bp[0] && w < bp[1]) return 'sm';\n      if (w >= bp[1] && w < bp[2]) return 'md';\n      return 'lg';\n    };\n\n    // Get and cache initial position of all elements\n    var cacheBlocks = function() {\n      for (var i = 0; i < self.elems.length; i++){\n        var block = createBlock(self.elems[i]);\n        blocks.push(block);\n      }\n    };\n\n\n    // Let's kick this script off\n    // Build array for cached element values\n    var init = function() {\n      for (var i = 0; i < blocks.length; i++){\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      blocks = [];\n\n      screenY = window.innerHeight;\n      screenX = window.innerWidth;\n      currentBreakpoint = getCurrentBreakpoint(screenX);\n\n      setPosition();\n\n      cacheBlocks();\n\n      animate();\n\n      // If paused, unpause and set listener for window resizing events\n      if (pause) {\n        window.addEventListener('resize', init);\n        pause = false;\n        // Start the loop\n        update();\n      }\n    };\n\n    // We want to cache the parallax blocks'\n    // values: base, top, height, speed\n    // el: is dom object, return: el cache values\n    var createBlock = function(el) {\n      var dataPercentage = el.getAttribute( 'data-rellax-percentage' );\n      var dataSpeed = el.getAttribute( 'data-rellax-speed' );\n      var dataXsSpeed = el.getAttribute( 'data-rellax-xs-speed' );\n      var dataMobileSpeed = el.getAttribute( 'data-rellax-mobile-speed' );\n      var dataTabletSpeed = el.getAttribute( 'data-rellax-tablet-speed' );\n      var dataDesktopSpeed = el.getAttribute( 'data-rellax-desktop-speed' );\n      var dataVerticalSpeed = el.getAttribute('data-rellax-vertical-speed');\n      var dataHorizontalSpeed = el.getAttribute('data-rellax-horizontal-speed');\n      var dataVericalScrollAxis = el.getAttribute('data-rellax-vertical-scroll-axis');\n      var dataHorizontalScrollAxis = el.getAttribute('data-rellax-horizontal-scroll-axis');\n      var dataZindex = el.getAttribute( 'data-rellax-zindex' ) || 0;\n      var dataMin = el.getAttribute( 'data-rellax-min' );\n      var dataMax = el.getAttribute( 'data-rellax-max' );\n      var dataMinX = el.getAttribute('data-rellax-min-x');\n      var dataMaxX = el.getAttribute('data-rellax-max-x');\n      var dataMinY = el.getAttribute('data-rellax-min-y');\n      var dataMaxY = el.getAttribute('data-rellax-max-y');\n      var mapBreakpoints;\n      var breakpoints = true;\n\n      if (!dataXsSpeed && !dataMobileSpeed && !dataTabletSpeed && !dataDesktopSpeed) {\n        breakpoints = false;\n      } else {\n        mapBreakpoints = {\n          'xs': dataXsSpeed,\n          'sm': dataMobileSpeed,\n          'md': dataTabletSpeed,\n          'lg': dataDesktopSpeed\n        };\n      }\n\n      // initializing at scrollY = 0 (top of browser), scrollX = 0 (left of browser)\n      // ensures elements are positioned based on HTML layout.\n      //\n      // If the element has the percentage attribute, the posY and posX needs to be\n      // the current scroll position's value, so that the elements are still positioned based on HTML layout\n      var wrapperPosY = self.options.wrapper ? self.options.wrapper.scrollTop : (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);\n      // If the option relativeToWrapper is true, use the wrappers offset to top, subtracted from the current page scroll.\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);\n        wrapperPosY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n      var posY = self.options.vertical ? ( dataPercentage || self.options.center ? wrapperPosY : 0 ) : 0;\n      var posX = self.options.horizontal ? ( dataPercentage || self.options.center ? self.options.wrapper ? self.options.wrapper.scrollLeft : (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft) : 0 ) : 0;\n\n      var blockTop = posY + el.getBoundingClientRect().top;\n      var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;\n\n      var blockLeft = posX + el.getBoundingClientRect().left;\n      var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth;\n\n      // apparently parallax equation everyone uses\n      var percentageY = dataPercentage ? dataPercentage : (posY - blockTop + screenY) / (blockHeight + screenY);\n      var percentageX = dataPercentage ? dataPercentage : (posX - blockLeft + screenX) / (blockWidth + screenX);\n      if(self.options.center){ percentageX = 0.5; percentageY = 0.5; }\n\n      // Optional individual block speed as data attr, otherwise global speed\n      var speed = (breakpoints && mapBreakpoints[currentBreakpoint] !== null) ? Number(mapBreakpoints[currentBreakpoint]) : (dataSpeed ? dataSpeed : self.options.speed);\n      var verticalSpeed = dataVerticalSpeed ? dataVerticalSpeed : self.options.verticalSpeed;\n      var horizontalSpeed = dataHorizontalSpeed ? dataHorizontalSpeed : self.options.horizontalSpeed;\n\n      // Optional individual block movement axis direction as data attr, otherwise gobal movement direction\n      var verticalScrollAxis = dataVericalScrollAxis ? dataVericalScrollAxis : self.options.verticalScrollAxis;\n      var horizontalScrollAxis = dataHorizontalScrollAxis ? dataHorizontalScrollAxis : self.options.horizontalScrollAxis;\n\n      var bases = updatePosition(percentageX, percentageY, speed, verticalSpeed, horizontalSpeed);\n\n      // ~~Store non-translate3d transforms~~\n      // Store inline styles and extract transforms\n      var style = el.style.cssText;\n      var transform = '';\n\n      // Check if there's an inline styled transform\n      var searchResult = /transform\\s*:/i.exec(style);\n      if (searchResult) {\n        // Get the index of the transform\n        var index = searchResult.index;\n\n        // Trim the style to the transform point and get the following semi-colon index\n        var trimmedStyle = style.slice(index);\n        var delimiter = trimmedStyle.indexOf(';');\n\n        // Remove \"transform\" string and save the attribute\n        if (delimiter) {\n          transform = \" \" + trimmedStyle.slice(11, delimiter).replace(/\\s/g,'');\n        } else {\n          transform = \" \" + trimmedStyle.slice(11).replace(/\\s/g,'');\n        }\n      }\n\n      return {\n        baseX: bases.x,\n        baseY: bases.y,\n        top: blockTop,\n        left: blockLeft,\n        height: blockHeight,\n        width: blockWidth,\n        speed: speed,\n        verticalSpeed: verticalSpeed,\n        horizontalSpeed: horizontalSpeed,\n        verticalScrollAxis: verticalScrollAxis,\n        horizontalScrollAxis: horizontalScrollAxis,\n        style: style,\n        transform: transform,\n        zindex: dataZindex,\n        min: dataMin,\n        max: dataMax,\n        minX: dataMinX,\n        maxX: dataMaxX,\n        minY: dataMinY,\n        maxY: dataMaxY\n      };\n    };\n\n    // set scroll position (posY, posX)\n    // side effect method is not ideal, but okay for now\n    // returns true if the scroll changed, false if nothing happened\n    var setPosition = function() {\n      var oldY = posY;\n      var oldX = posX;\n\n      posY = self.options.wrapper ? self.options.wrapper.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n      posX = self.options.wrapper ? self.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset;\n      // If option relativeToWrapper is true, use relative wrapper value instead.\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n        posY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n\n\n      if (oldY != posY && self.options.vertical) {\n        // scroll changed, return true\n        return true;\n      }\n\n      if (oldX != posX && self.options.horizontal) {\n        // scroll changed, return true\n        return true;\n      }\n\n      // scroll did not change\n      return false;\n    };\n\n    // Ahh a pure function, gets new transform value\n    // based on scrollPosition and speed\n    // Allow for decimal pixel values\n    var updatePosition = function(percentageX, percentageY, speed, verticalSpeed, horizontalSpeed) {\n      var result = {};\n      var valueX = ((horizontalSpeed ? horizontalSpeed : speed) * (100 * (1 - percentageX)));\n      var valueY = ((verticalSpeed ? verticalSpeed : speed) * (100 * (1 - percentageY)));\n\n      result.x = self.options.round ? Math.round(valueX) : Math.round(valueX * 100) / 100;\n      result.y = self.options.round ? Math.round(valueY) : Math.round(valueY * 100) / 100;\n\n      return result;\n    };\n\n    // Remove event listeners and loop again\n    var deferredUpdate = function() {\n      window.removeEventListener('resize', deferredUpdate);\n      window.removeEventListener('orientationchange', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : window).removeEventListener('scroll', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : document).removeEventListener('touchmove', deferredUpdate);\n\n      // loop again\n      loopId = loop(update);\n    };\n\n    // Loop\n    var update = function() {\n      if (setPosition() && pause === false) {\n        animate();\n\n        // loop again\n        loopId = loop(update);\n      } else {\n        loopId = null;\n\n        // Don't animate until we get a position updating event\n        window.addEventListener('resize', deferredUpdate);\n        window.addEventListener('orientationchange', deferredUpdate);\n        (self.options.wrapper ? self.options.wrapper : window).addEventListener('scroll', deferredUpdate, supportsPassive ? { passive: true } : false);\n        (self.options.wrapper ? self.options.wrapper : document).addEventListener('touchmove', deferredUpdate, supportsPassive ? { passive: true } : false);\n      }\n    };\n\n    // Transform3d on parallax element\n    var animate = function() {\n      var positions;\n      for (var i = 0; i < self.elems.length; i++){\n        // Determine relevant movement directions\n        var verticalScrollAxis = blocks[i].verticalScrollAxis.toLowerCase();\n        var horizontalScrollAxis = blocks[i].horizontalScrollAxis.toLowerCase();\n        var verticalScrollX = verticalScrollAxis.indexOf(\"x\") != -1 ? posY : 0;\n        var verticalScrollY = verticalScrollAxis.indexOf(\"y\") != -1 ? posY : 0;\n        var horizontalScrollX = horizontalScrollAxis.indexOf(\"x\") != -1 ? posX : 0;\n        var horizontalScrollY = horizontalScrollAxis.indexOf(\"y\") != -1 ? posX : 0;\n\n        var percentageY = ((verticalScrollY + horizontalScrollY - blocks[i].top + screenY) / (blocks[i].height + screenY));\n        var percentageX = ((verticalScrollX + horizontalScrollX - blocks[i].left + screenX) / (blocks[i].width + screenX));\n\n        // Subtracting initialize value, so element stays in same spot as HTML\n        positions = updatePosition(percentageX, percentageY, blocks[i].speed, blocks[i].verticalSpeed, blocks[i].horizontalSpeed);\n        var positionY = positions.y - blocks[i].baseY;\n        var positionX = positions.x - blocks[i].baseX;\n\n        // The next two \"if\" blocks go like this:\n        // Check if a limit is defined (first \"min\", then \"max\");\n        // Check if we need to change the Y or the X\n        // (Currently working only if just one of the axes is enabled)\n        // Then, check if the new position is inside the allowed limit\n        // If so, use new position. If not, set position to limit.\n\n        // Check if a min limit is defined\n        if (blocks[i].min !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY <= blocks[i].min ? blocks[i].min : positionY;\n          }\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX <= blocks[i].min ? blocks[i].min : positionX;\n          }\n        }\n\n        // Check if directional min limits are defined\n        if (blocks[i].minY != null) {\n            positionY = positionY <= blocks[i].minY ? blocks[i].minY : positionY;\n        }\n        if (blocks[i].minX != null) {\n            positionX = positionX <= blocks[i].minX ? blocks[i].minX : positionX;\n        }\n\n        // Check if a max limit is defined\n        if (blocks[i].max !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY >= blocks[i].max ? blocks[i].max : positionY;\n          }\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX >= blocks[i].max ? blocks[i].max : positionX;\n          }\n        }\n\n        // Check if directional max limits are defined\n        if (blocks[i].maxY != null) {\n            positionY = positionY >= blocks[i].maxY ? blocks[i].maxY : positionY;\n        }\n        if (blocks[i].maxX != null) {\n            positionX = positionX >= blocks[i].maxX ? blocks[i].maxX : positionX;\n        }\n\n        var zindex = blocks[i].zindex;\n\n        // Move that element\n        // (Set the new translation and append initial inline transforms.)\n        var translate = 'translate3d(' + (self.options.horizontal ? positionX : '0') + 'px,' + (self.options.vertical ? positionY : '0') + 'px,' + zindex + 'px) ' + blocks[i].transform;\n        self.elems[i].style[transformProp] = translate;\n      }\n      self.options.callback(positions);\n    };\n\n    self.destroy = function() {\n      for (var i = 0; i < self.elems.length; i++){\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      // Remove resize event listener if not pause, and pause\n      if (!pause) {\n        window.removeEventListener('resize', init);\n        pause = true;\n      }\n\n      // Clear the animation loop to prevent possible memory leak\n      clearLoop(loopId);\n      loopId = null;\n    };\n\n    // Init\n    init();\n\n    // Allow to recalculate the initial values whenever we want\n    self.refresh = init;\n\n    return self;\n  };\n  return Rellax;\n}));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVsbGF4L3JlbGxheC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWxsYXgvcmVsbGF4LmpzPzFkYjMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlbGxheC5qc1xuLy8gQnV0dGVyeSBzbW9vdGggcGFyYWxsYXggbGlicmFyeVxuLy8gQ29weXJpZ2h0IChjKSAyMDE2IE1vZSBBbWF5YSAoQG1vZWFtYXlhKVxuLy8gTUlUIGxpY2Vuc2Vcbi8vXG4vLyBUaGFua3MgdG8gUGFyYXhpZnkuanMgYW5kIEphaW1lIENhYmxsZXJvXG4vLyBmb3IgcGFyYWxsYXggY29uY2VwdHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgLy8gbGlrZSBOb2RlLlxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgcm9vdC5SZWxsYXggPSBmYWN0b3J5KCk7XG4gIH1cbn0odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICB2YXIgUmVsbGF4ID0gZnVuY3Rpb24oZWwsIG9wdGlvbnMpe1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHNlbGYgPSBPYmplY3QuY3JlYXRlKFJlbGxheC5wcm90b3R5cGUpO1xuXG4gICAgdmFyIHBvc1kgPSAwO1xuICAgIHZhciBzY3JlZW5ZID0gMDtcbiAgICB2YXIgcG9zWCA9IDA7XG4gICAgdmFyIHNjcmVlblggPSAwO1xuICAgIHZhciBibG9ja3MgPSBbXTtcbiAgICB2YXIgcGF1c2UgPSB0cnVlO1xuXG4gICAgLy8gY2hlY2sgd2hhdCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdG8gdXNlLCBhbmQgaWZcbiAgICAvLyBpdCdzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgb25zY3JvbGwgZXZlbnRcbiAgICB2YXIgbG9vcCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIGZ1bmN0aW9uKGNhbGxiYWNrKXsgcmV0dXJuIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7IH07XG5cbiAgICAvLyBzdG9yZSB0aGUgaWQgZm9yIGxhdGVyIHVzZVxuICAgIHZhciBsb29wSWQgPSBudWxsO1xuXG4gICAgLy8gVGVzdCB2aWEgYSBnZXR0ZXIgaW4gdGhlIG9wdGlvbnMgb2JqZWN0IHRvIHNlZSBpZiB0aGUgcGFzc2l2ZSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZFxuICAgIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0UGFzc2l2ZVwiLCBudWxsLCBvcHRzKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFBhc3NpdmVcIiwgbnVsbCwgb3B0cyk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIGNoZWNrIHdoYXQgY2FuY2VsQW5pbWF0aW9uIG1ldGhvZCB0byB1c2VcbiAgICB2YXIgY2xlYXJMb29wID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fCBjbGVhclRpbWVvdXQ7XG5cbiAgICAvLyBjaGVjayB3aGljaCB0cmFuc2Zvcm0gcHJvcGVydHkgdG8gdXNlXG4gICAgdmFyIHRyYW5zZm9ybVByb3AgPSB3aW5kb3cudHJhbnNmb3JtUHJvcCB8fCAoZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHRlc3RFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBpZiAodGVzdEVsLnN0eWxlLnRyYW5zZm9ybSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciB2ZW5kb3JzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG4gICAgICAgICAgZm9yICh2YXIgdmVuZG9yIGluIHZlbmRvcnMpIHtcbiAgICAgICAgICAgIGlmICh0ZXN0RWwuc3R5bGVbIHZlbmRvcnNbdmVuZG9yXSArICdUcmFuc2Zvcm0nIF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdmVuZG9yc1t2ZW5kb3JdICsgJ1RyYW5zZm9ybSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAndHJhbnNmb3JtJztcbiAgICAgIH0pKCk7XG5cbiAgICAvLyBEZWZhdWx0IFNldHRpbmdzXG4gICAgc2VsZi5vcHRpb25zID0ge1xuICAgICAgc3BlZWQ6IC0yLFxuXHQgICAgdmVydGljYWxTcGVlZDogbnVsbCxcblx0ICAgIGhvcml6b250YWxTcGVlZDogbnVsbCxcbiAgICAgIGJyZWFrcG9pbnRzOiBbNTc2LCA3NjgsIDEyMDFdLFxuICAgICAgY2VudGVyOiBmYWxzZSxcbiAgICAgIHdyYXBwZXI6IG51bGwsXG4gICAgICByZWxhdGl2ZVRvV3JhcHBlcjogZmFsc2UsXG4gICAgICByb3VuZDogdHJ1ZSxcbiAgICAgIHZlcnRpY2FsOiB0cnVlLFxuICAgICAgaG9yaXpvbnRhbDogZmFsc2UsXG4gICAgICB2ZXJ0aWNhbFNjcm9sbEF4aXM6IFwieVwiLFxuICAgICAgaG9yaXpvbnRhbFNjcm9sbEF4aXM6IFwieFwiLFxuICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge30sXG4gICAgfTtcblxuICAgIC8vIFVzZXIgZGVmaW5lZCBvcHRpb25zIChtaWdodCBoYXZlIG1vcmUgaW4gdGhlIGZ1dHVyZSlcbiAgICBpZiAob3B0aW9ucyl7XG4gICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIHNlbGYub3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDdXN0b21CcmVha3BvaW50cyAoKSB7XG4gICAgICBpZiAoc2VsZi5vcHRpb25zLmJyZWFrcG9pbnRzLmxlbmd0aCA9PT0gMyAmJiBBcnJheS5pc0FycmF5KHNlbGYub3B0aW9ucy5icmVha3BvaW50cykpIHtcbiAgICAgICAgdmFyIGlzQXNjZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdmFyIGlzTnVtZXJpY2FsID0gdHJ1ZTtcbiAgICAgICAgdmFyIGxhc3RWYWw7XG4gICAgICAgIHNlbGYub3B0aW9ucy5icmVha3BvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnbnVtYmVyJykgaXNOdW1lcmljYWwgPSBmYWxzZTtcbiAgICAgICAgICBpZiAobGFzdFZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGkgPCBsYXN0VmFsKSBpc0FzY2VuZGluZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0VmFsID0gaTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0FzY2VuZGluZyAmJiBpc051bWVyaWNhbCkgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gcmV2ZXJ0IGRlZmF1bHRzIGlmIHNldCBpbmNvcnJlY3RseVxuICAgICAgc2VsZi5vcHRpb25zLmJyZWFrcG9pbnRzID0gWzU3NiwgNzY4LCAxMjAxXTtcbiAgICAgIGNvbnNvbGUud2FybihcIlJlbGxheDogWW91IG11c3QgcGFzcyBhbiBhcnJheSBvZiAzIG51bWJlcnMgaW4gYXNjZW5kaW5nIG9yZGVyIHRvIHRoZSBicmVha3BvaW50cyBvcHRpb24uIERlZmF1bHRzIHJldmVydGVkXCIpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYnJlYWtwb2ludHMpIHtcbiAgICAgIHZhbGlkYXRlQ3VzdG9tQnJlYWtwb2ludHMoKTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCByZWxsYXggY2xhc3NcbiAgICBpZiAoIWVsKSB7XG4gICAgICBlbCA9ICcucmVsbGF4JztcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBlbCBpcyBhIGNsYXNzTmFtZSBvciBhIG5vZGVcbiAgICB2YXIgZWxlbWVudHMgPSB0eXBlb2YgZWwgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlbCkgOiBbZWxdO1xuXG4gICAgLy8gTm93IHF1ZXJ5IHNlbGVjdG9yXG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHNlbGYuZWxlbXMgPSBlbGVtZW50cztcbiAgICB9XG5cbiAgICAvLyBUaGUgZWxlbWVudHMgZG9uJ3QgZXhpc3RcbiAgICBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlJlbGxheDogVGhlIGVsZW1lbnRzIHlvdSdyZSB0cnlpbmcgdG8gc2VsZWN0IGRvbid0IGV4aXN0LlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBIYXMgYSB3cmFwcGVyIGFuZCBpdCBleGlzdHNcbiAgICBpZiAoc2VsZi5vcHRpb25zLndyYXBwZXIpIHtcbiAgICAgIGlmICghc2VsZi5vcHRpb25zLndyYXBwZXIubm9kZVR5cGUpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGYub3B0aW9ucy53cmFwcGVyKTtcblxuICAgICAgICBpZiAod3JhcHBlcikge1xuICAgICAgICAgIHNlbGYub3B0aW9ucy53cmFwcGVyID0gd3JhcHBlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJSZWxsYXg6IFRoZSB3cmFwcGVyIHlvdSdyZSB0cnlpbmcgdG8gdXNlIGRvZXNuJ3QgZXhpc3QuXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldCBhIHBsYWNlaG9sZGVyIGZvciB0aGUgY3VycmVudCBicmVha3BvaW50XG4gICAgdmFyIGN1cnJlbnRCcmVha3BvaW50O1xuXG4gICAgLy8gaGVscGVyIHRvIGRldGVybWluZSBjdXJyZW50IGJyZWFrcG9pbnRcbiAgICB2YXIgZ2V0Q3VycmVudEJyZWFrcG9pbnQgPSBmdW5jdGlvbiAodykge1xuICAgICAgdmFyIGJwID0gc2VsZi5vcHRpb25zLmJyZWFrcG9pbnRzO1xuICAgICAgaWYgKHcgPCBicFswXSkgcmV0dXJuICd4cyc7XG4gICAgICBpZiAodyA+PSBicFswXSAmJiB3IDwgYnBbMV0pIHJldHVybiAnc20nO1xuICAgICAgaWYgKHcgPj0gYnBbMV0gJiYgdyA8IGJwWzJdKSByZXR1cm4gJ21kJztcbiAgICAgIHJldHVybiAnbGcnO1xuICAgIH07XG5cbiAgICAvLyBHZXQgYW5kIGNhY2hlIGluaXRpYWwgcG9zaXRpb24gb2YgYWxsIGVsZW1lbnRzXG4gICAgdmFyIGNhY2hlQmxvY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuZWxlbXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYmxvY2sgPSBjcmVhdGVCbG9jayhzZWxmLmVsZW1zW2ldKTtcbiAgICAgICAgYmxvY2tzLnB1c2goYmxvY2spO1xuICAgICAgfVxuICAgIH07XG5cblxuICAgIC8vIExldCdzIGtpY2sgdGhpcyBzY3JpcHQgb2ZmXG4gICAgLy8gQnVpbGQgYXJyYXkgZm9yIGNhY2hlZCBlbGVtZW50IHZhbHVlc1xuICAgIHZhciBpbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHNlbGYuZWxlbXNbaV0uc3R5bGUuY3NzVGV4dCA9IGJsb2Nrc1tpXS5zdHlsZTtcbiAgICAgIH1cblxuICAgICAgYmxvY2tzID0gW107XG5cbiAgICAgIHNjcmVlblkgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBzY3JlZW5YID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBjdXJyZW50QnJlYWtwb2ludCA9IGdldEN1cnJlbnRCcmVha3BvaW50KHNjcmVlblgpO1xuXG4gICAgICBzZXRQb3NpdGlvbigpO1xuXG4gICAgICBjYWNoZUJsb2NrcygpO1xuXG4gICAgICBhbmltYXRlKCk7XG5cbiAgICAgIC8vIElmIHBhdXNlZCwgdW5wYXVzZSBhbmQgc2V0IGxpc3RlbmVyIGZvciB3aW5kb3cgcmVzaXppbmcgZXZlbnRzXG4gICAgICBpZiAocGF1c2UpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluaXQpO1xuICAgICAgICBwYXVzZSA9IGZhbHNlO1xuICAgICAgICAvLyBTdGFydCB0aGUgbG9vcFxuICAgICAgICB1cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gV2Ugd2FudCB0byBjYWNoZSB0aGUgcGFyYWxsYXggYmxvY2tzJ1xuICAgIC8vIHZhbHVlczogYmFzZSwgdG9wLCBoZWlnaHQsIHNwZWVkXG4gICAgLy8gZWw6IGlzIGRvbSBvYmplY3QsIHJldHVybjogZWwgY2FjaGUgdmFsdWVzXG4gICAgdmFyIGNyZWF0ZUJsb2NrID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBkYXRhUGVyY2VudGFnZSA9IGVsLmdldEF0dHJpYnV0ZSggJ2RhdGEtcmVsbGF4LXBlcmNlbnRhZ2UnICk7XG4gICAgICB2YXIgZGF0YVNwZWVkID0gZWwuZ2V0QXR0cmlidXRlKCAnZGF0YS1yZWxsYXgtc3BlZWQnICk7XG4gICAgICB2YXIgZGF0YVhzU3BlZWQgPSBlbC5nZXRBdHRyaWJ1dGUoICdkYXRhLXJlbGxheC14cy1zcGVlZCcgKTtcbiAgICAgIHZhciBkYXRhTW9iaWxlU3BlZWQgPSBlbC5nZXRBdHRyaWJ1dGUoICdkYXRhLXJlbGxheC1tb2JpbGUtc3BlZWQnICk7XG4gICAgICB2YXIgZGF0YVRhYmxldFNwZWVkID0gZWwuZ2V0QXR0cmlidXRlKCAnZGF0YS1yZWxsYXgtdGFibGV0LXNwZWVkJyApO1xuICAgICAgdmFyIGRhdGFEZXNrdG9wU3BlZWQgPSBlbC5nZXRBdHRyaWJ1dGUoICdkYXRhLXJlbGxheC1kZXNrdG9wLXNwZWVkJyApO1xuICAgICAgdmFyIGRhdGFWZXJ0aWNhbFNwZWVkID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXJlbGxheC12ZXJ0aWNhbC1zcGVlZCcpO1xuICAgICAgdmFyIGRhdGFIb3Jpem9udGFsU3BlZWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmVsbGF4LWhvcml6b250YWwtc3BlZWQnKTtcbiAgICAgIHZhciBkYXRhVmVyaWNhbFNjcm9sbEF4aXMgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmVsbGF4LXZlcnRpY2FsLXNjcm9sbC1heGlzJyk7XG4gICAgICB2YXIgZGF0YUhvcml6b250YWxTY3JvbGxBeGlzID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXJlbGxheC1ob3Jpem9udGFsLXNjcm9sbC1heGlzJyk7XG4gICAgICB2YXIgZGF0YVppbmRleCA9IGVsLmdldEF0dHJpYnV0ZSggJ2RhdGEtcmVsbGF4LXppbmRleCcgKSB8fCAwO1xuICAgICAgdmFyIGRhdGFNaW4gPSBlbC5nZXRBdHRyaWJ1dGUoICdkYXRhLXJlbGxheC1taW4nICk7XG4gICAgICB2YXIgZGF0YU1heCA9IGVsLmdldEF0dHJpYnV0ZSggJ2RhdGEtcmVsbGF4LW1heCcgKTtcbiAgICAgIHZhciBkYXRhTWluWCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1yZWxsYXgtbWluLXgnKTtcbiAgICAgIHZhciBkYXRhTWF4WCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1yZWxsYXgtbWF4LXgnKTtcbiAgICAgIHZhciBkYXRhTWluWSA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1yZWxsYXgtbWluLXknKTtcbiAgICAgIHZhciBkYXRhTWF4WSA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1yZWxsYXgtbWF4LXknKTtcbiAgICAgIHZhciBtYXBCcmVha3BvaW50cztcbiAgICAgIHZhciBicmVha3BvaW50cyA9IHRydWU7XG5cbiAgICAgIGlmICghZGF0YVhzU3BlZWQgJiYgIWRhdGFNb2JpbGVTcGVlZCAmJiAhZGF0YVRhYmxldFNwZWVkICYmICFkYXRhRGVza3RvcFNwZWVkKSB7XG4gICAgICAgIGJyZWFrcG9pbnRzID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXBCcmVha3BvaW50cyA9IHtcbiAgICAgICAgICAneHMnOiBkYXRhWHNTcGVlZCxcbiAgICAgICAgICAnc20nOiBkYXRhTW9iaWxlU3BlZWQsXG4gICAgICAgICAgJ21kJzogZGF0YVRhYmxldFNwZWVkLFxuICAgICAgICAgICdsZyc6IGRhdGFEZXNrdG9wU3BlZWRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gaW5pdGlhbGl6aW5nIGF0IHNjcm9sbFkgPSAwICh0b3Agb2YgYnJvd3NlciksIHNjcm9sbFggPSAwIChsZWZ0IG9mIGJyb3dzZXIpXG4gICAgICAvLyBlbnN1cmVzIGVsZW1lbnRzIGFyZSBwb3NpdGlvbmVkIGJhc2VkIG9uIEhUTUwgbGF5b3V0LlxuICAgICAgLy9cbiAgICAgIC8vIElmIHRoZSBlbGVtZW50IGhhcyB0aGUgcGVyY2VudGFnZSBhdHRyaWJ1dGUsIHRoZSBwb3NZIGFuZCBwb3NYIG5lZWRzIHRvIGJlXG4gICAgICAvLyB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24ncyB2YWx1ZSwgc28gdGhhdCB0aGUgZWxlbWVudHMgYXJlIHN0aWxsIHBvc2l0aW9uZWQgYmFzZWQgb24gSFRNTCBsYXlvdXRcbiAgICAgIHZhciB3cmFwcGVyUG9zWSA9IHNlbGYub3B0aW9ucy53cmFwcGVyID8gc2VsZi5vcHRpb25zLndyYXBwZXIuc2Nyb2xsVG9wIDogKHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKTtcbiAgICAgIC8vIElmIHRoZSBvcHRpb24gcmVsYXRpdmVUb1dyYXBwZXIgaXMgdHJ1ZSwgdXNlIHRoZSB3cmFwcGVycyBvZmZzZXQgdG8gdG9wLCBzdWJ0cmFjdGVkIGZyb20gdGhlIGN1cnJlbnQgcGFnZSBzY3JvbGwuXG4gICAgICBpZiAoc2VsZi5vcHRpb25zLnJlbGF0aXZlVG9XcmFwcGVyKSB7XG4gICAgICAgIHZhciBzY3JvbGxQb3NZID0gKHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKTtcbiAgICAgICAgd3JhcHBlclBvc1kgPSBzY3JvbGxQb3NZIC0gc2VsZi5vcHRpb25zLndyYXBwZXIub2Zmc2V0VG9wO1xuICAgICAgfVxuICAgICAgdmFyIHBvc1kgPSBzZWxmLm9wdGlvbnMudmVydGljYWwgPyAoIGRhdGFQZXJjZW50YWdlIHx8IHNlbGYub3B0aW9ucy5jZW50ZXIgPyB3cmFwcGVyUG9zWSA6IDAgKSA6IDA7XG4gICAgICB2YXIgcG9zWCA9IHNlbGYub3B0aW9ucy5ob3Jpem9udGFsID8gKCBkYXRhUGVyY2VudGFnZSB8fCBzZWxmLm9wdGlvbnMuY2VudGVyID8gc2VsZi5vcHRpb25zLndyYXBwZXIgPyBzZWxmLm9wdGlvbnMud3JhcHBlci5zY3JvbGxMZWZ0IDogKHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQpIDogMCApIDogMDtcblxuICAgICAgdmFyIGJsb2NrVG9wID0gcG9zWSArIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgIHZhciBibG9ja0hlaWdodCA9IGVsLmNsaWVudEhlaWdodCB8fCBlbC5vZmZzZXRIZWlnaHQgfHwgZWwuc2Nyb2xsSGVpZ2h0O1xuXG4gICAgICB2YXIgYmxvY2tMZWZ0ID0gcG9zWCArIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICB2YXIgYmxvY2tXaWR0aCA9IGVsLmNsaWVudFdpZHRoIHx8IGVsLm9mZnNldFdpZHRoIHx8IGVsLnNjcm9sbFdpZHRoO1xuXG4gICAgICAvLyBhcHBhcmVudGx5IHBhcmFsbGF4IGVxdWF0aW9uIGV2ZXJ5b25lIHVzZXNcbiAgICAgIHZhciBwZXJjZW50YWdlWSA9IGRhdGFQZXJjZW50YWdlID8gZGF0YVBlcmNlbnRhZ2UgOiAocG9zWSAtIGJsb2NrVG9wICsgc2NyZWVuWSkgLyAoYmxvY2tIZWlnaHQgKyBzY3JlZW5ZKTtcbiAgICAgIHZhciBwZXJjZW50YWdlWCA9IGRhdGFQZXJjZW50YWdlID8gZGF0YVBlcmNlbnRhZ2UgOiAocG9zWCAtIGJsb2NrTGVmdCArIHNjcmVlblgpIC8gKGJsb2NrV2lkdGggKyBzY3JlZW5YKTtcbiAgICAgIGlmKHNlbGYub3B0aW9ucy5jZW50ZXIpeyBwZXJjZW50YWdlWCA9IDAuNTsgcGVyY2VudGFnZVkgPSAwLjU7IH1cblxuICAgICAgLy8gT3B0aW9uYWwgaW5kaXZpZHVhbCBibG9jayBzcGVlZCBhcyBkYXRhIGF0dHIsIG90aGVyd2lzZSBnbG9iYWwgc3BlZWRcbiAgICAgIHZhciBzcGVlZCA9IChicmVha3BvaW50cyAmJiBtYXBCcmVha3BvaW50c1tjdXJyZW50QnJlYWtwb2ludF0gIT09IG51bGwpID8gTnVtYmVyKG1hcEJyZWFrcG9pbnRzW2N1cnJlbnRCcmVha3BvaW50XSkgOiAoZGF0YVNwZWVkID8gZGF0YVNwZWVkIDogc2VsZi5vcHRpb25zLnNwZWVkKTtcbiAgICAgIHZhciB2ZXJ0aWNhbFNwZWVkID0gZGF0YVZlcnRpY2FsU3BlZWQgPyBkYXRhVmVydGljYWxTcGVlZCA6IHNlbGYub3B0aW9ucy52ZXJ0aWNhbFNwZWVkO1xuICAgICAgdmFyIGhvcml6b250YWxTcGVlZCA9IGRhdGFIb3Jpem9udGFsU3BlZWQgPyBkYXRhSG9yaXpvbnRhbFNwZWVkIDogc2VsZi5vcHRpb25zLmhvcml6b250YWxTcGVlZDtcblxuICAgICAgLy8gT3B0aW9uYWwgaW5kaXZpZHVhbCBibG9jayBtb3ZlbWVudCBheGlzIGRpcmVjdGlvbiBhcyBkYXRhIGF0dHIsIG90aGVyd2lzZSBnb2JhbCBtb3ZlbWVudCBkaXJlY3Rpb25cbiAgICAgIHZhciB2ZXJ0aWNhbFNjcm9sbEF4aXMgPSBkYXRhVmVyaWNhbFNjcm9sbEF4aXMgPyBkYXRhVmVyaWNhbFNjcm9sbEF4aXMgOiBzZWxmLm9wdGlvbnMudmVydGljYWxTY3JvbGxBeGlzO1xuICAgICAgdmFyIGhvcml6b250YWxTY3JvbGxBeGlzID0gZGF0YUhvcml6b250YWxTY3JvbGxBeGlzID8gZGF0YUhvcml6b250YWxTY3JvbGxBeGlzIDogc2VsZi5vcHRpb25zLmhvcml6b250YWxTY3JvbGxBeGlzO1xuXG4gICAgICB2YXIgYmFzZXMgPSB1cGRhdGVQb3NpdGlvbihwZXJjZW50YWdlWCwgcGVyY2VudGFnZVksIHNwZWVkLCB2ZXJ0aWNhbFNwZWVkLCBob3Jpem9udGFsU3BlZWQpO1xuXG4gICAgICAvLyB+flN0b3JlIG5vbi10cmFuc2xhdGUzZCB0cmFuc2Zvcm1zfn5cbiAgICAgIC8vIFN0b3JlIGlubGluZSBzdHlsZXMgYW5kIGV4dHJhY3QgdHJhbnNmb3Jtc1xuICAgICAgdmFyIHN0eWxlID0gZWwuc3R5bGUuY3NzVGV4dDtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSAnJztcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbiBpbmxpbmUgc3R5bGVkIHRyYW5zZm9ybVxuICAgICAgdmFyIHNlYXJjaFJlc3VsdCA9IC90cmFuc2Zvcm1cXHMqOi9pLmV4ZWMoc3R5bGUpO1xuICAgICAgaWYgKHNlYXJjaFJlc3VsdCkge1xuICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSB0cmFuc2Zvcm1cbiAgICAgICAgdmFyIGluZGV4ID0gc2VhcmNoUmVzdWx0LmluZGV4O1xuXG4gICAgICAgIC8vIFRyaW0gdGhlIHN0eWxlIHRvIHRoZSB0cmFuc2Zvcm0gcG9pbnQgYW5kIGdldCB0aGUgZm9sbG93aW5nIHNlbWktY29sb24gaW5kZXhcbiAgICAgICAgdmFyIHRyaW1tZWRTdHlsZSA9IHN0eWxlLnNsaWNlKGluZGV4KTtcbiAgICAgICAgdmFyIGRlbGltaXRlciA9IHRyaW1tZWRTdHlsZS5pbmRleE9mKCc7Jyk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIFwidHJhbnNmb3JtXCIgc3RyaW5nIGFuZCBzYXZlIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgaWYgKGRlbGltaXRlcikge1xuICAgICAgICAgIHRyYW5zZm9ybSA9IFwiIFwiICsgdHJpbW1lZFN0eWxlLnNsaWNlKDExLCBkZWxpbWl0ZXIpLnJlcGxhY2UoL1xccy9nLCcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBcIiBcIiArIHRyaW1tZWRTdHlsZS5zbGljZSgxMSkucmVwbGFjZSgvXFxzL2csJycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VYOiBiYXNlcy54LFxuICAgICAgICBiYXNlWTogYmFzZXMueSxcbiAgICAgICAgdG9wOiBibG9ja1RvcCxcbiAgICAgICAgbGVmdDogYmxvY2tMZWZ0LFxuICAgICAgICBoZWlnaHQ6IGJsb2NrSGVpZ2h0LFxuICAgICAgICB3aWR0aDogYmxvY2tXaWR0aCxcbiAgICAgICAgc3BlZWQ6IHNwZWVkLFxuICAgICAgICB2ZXJ0aWNhbFNwZWVkOiB2ZXJ0aWNhbFNwZWVkLFxuICAgICAgICBob3Jpem9udGFsU3BlZWQ6IGhvcml6b250YWxTcGVlZCxcbiAgICAgICAgdmVydGljYWxTY3JvbGxBeGlzOiB2ZXJ0aWNhbFNjcm9sbEF4aXMsXG4gICAgICAgIGhvcml6b250YWxTY3JvbGxBeGlzOiBob3Jpem9udGFsU2Nyb2xsQXhpcyxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgemluZGV4OiBkYXRhWmluZGV4LFxuICAgICAgICBtaW46IGRhdGFNaW4sXG4gICAgICAgIG1heDogZGF0YU1heCxcbiAgICAgICAgbWluWDogZGF0YU1pblgsXG4gICAgICAgIG1heFg6IGRhdGFNYXhYLFxuICAgICAgICBtaW5ZOiBkYXRhTWluWSxcbiAgICAgICAgbWF4WTogZGF0YU1heFlcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIHNldCBzY3JvbGwgcG9zaXRpb24gKHBvc1ksIHBvc1gpXG4gICAgLy8gc2lkZSBlZmZlY3QgbWV0aG9kIGlzIG5vdCBpZGVhbCwgYnV0IG9rYXkgZm9yIG5vd1xuICAgIC8vIHJldHVybnMgdHJ1ZSBpZiB0aGUgc2Nyb2xsIGNoYW5nZWQsIGZhbHNlIGlmIG5vdGhpbmcgaGFwcGVuZWRcbiAgICB2YXIgc2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvbGRZID0gcG9zWTtcbiAgICAgIHZhciBvbGRYID0gcG9zWDtcblxuICAgICAgcG9zWSA9IHNlbGYub3B0aW9ucy53cmFwcGVyID8gc2VsZi5vcHRpb25zLndyYXBwZXIuc2Nyb2xsVG9wIDogKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuYm9keSkuc2Nyb2xsVG9wIHx8IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgIHBvc1ggPSBzZWxmLm9wdGlvbnMud3JhcHBlciA/IHNlbGYub3B0aW9ucy53cmFwcGVyLnNjcm9sbExlZnQgOiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZSB8fCBkb2N1bWVudC5ib2R5KS5zY3JvbGxMZWZ0IHx8IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICAgIC8vIElmIG9wdGlvbiByZWxhdGl2ZVRvV3JhcHBlciBpcyB0cnVlLCB1c2UgcmVsYXRpdmUgd3JhcHBlciB2YWx1ZSBpbnN0ZWFkLlxuICAgICAgaWYgKHNlbGYub3B0aW9ucy5yZWxhdGl2ZVRvV3JhcHBlcikge1xuICAgICAgICB2YXIgc2Nyb2xsUG9zWSA9IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlIHx8IGRvY3VtZW50LmJvZHkpLnNjcm9sbFRvcCB8fCB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIHBvc1kgPSBzY3JvbGxQb3NZIC0gc2VsZi5vcHRpb25zLndyYXBwZXIub2Zmc2V0VG9wO1xuICAgICAgfVxuXG5cbiAgICAgIGlmIChvbGRZICE9IHBvc1kgJiYgc2VsZi5vcHRpb25zLnZlcnRpY2FsKSB7XG4gICAgICAgIC8vIHNjcm9sbCBjaGFuZ2VkLCByZXR1cm4gdHJ1ZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9sZFggIT0gcG9zWCAmJiBzZWxmLm9wdGlvbnMuaG9yaXpvbnRhbCkge1xuICAgICAgICAvLyBzY3JvbGwgY2hhbmdlZCwgcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHNjcm9sbCBkaWQgbm90IGNoYW5nZVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyBBaGggYSBwdXJlIGZ1bmN0aW9uLCBnZXRzIG5ldyB0cmFuc2Zvcm0gdmFsdWVcbiAgICAvLyBiYXNlZCBvbiBzY3JvbGxQb3NpdGlvbiBhbmQgc3BlZWRcbiAgICAvLyBBbGxvdyBmb3IgZGVjaW1hbCBwaXhlbCB2YWx1ZXNcbiAgICB2YXIgdXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbihwZXJjZW50YWdlWCwgcGVyY2VudGFnZVksIHNwZWVkLCB2ZXJ0aWNhbFNwZWVkLCBob3Jpem9udGFsU3BlZWQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIHZhciB2YWx1ZVggPSAoKGhvcml6b250YWxTcGVlZCA/IGhvcml6b250YWxTcGVlZCA6IHNwZWVkKSAqICgxMDAgKiAoMSAtIHBlcmNlbnRhZ2VYKSkpO1xuICAgICAgdmFyIHZhbHVlWSA9ICgodmVydGljYWxTcGVlZCA/IHZlcnRpY2FsU3BlZWQgOiBzcGVlZCkgKiAoMTAwICogKDEgLSBwZXJjZW50YWdlWSkpKTtcblxuICAgICAgcmVzdWx0LnggPSBzZWxmLm9wdGlvbnMucm91bmQgPyBNYXRoLnJvdW5kKHZhbHVlWCkgOiBNYXRoLnJvdW5kKHZhbHVlWCAqIDEwMCkgLyAxMDA7XG4gICAgICByZXN1bHQueSA9IHNlbGYub3B0aW9ucy5yb3VuZCA/IE1hdGgucm91bmQodmFsdWVZKSA6IE1hdGgucm91bmQodmFsdWVZICogMTAwKSAvIDEwMDtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBhbmQgbG9vcCBhZ2FpblxuICAgIHZhciBkZWZlcnJlZFVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGRlZmVycmVkVXBkYXRlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIGRlZmVycmVkVXBkYXRlKTtcbiAgICAgIChzZWxmLm9wdGlvbnMud3JhcHBlciA/IHNlbGYub3B0aW9ucy53cmFwcGVyIDogd2luZG93KS5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBkZWZlcnJlZFVwZGF0ZSk7XG4gICAgICAoc2VsZi5vcHRpb25zLndyYXBwZXIgPyBzZWxmLm9wdGlvbnMud3JhcHBlciA6IGRvY3VtZW50KS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBkZWZlcnJlZFVwZGF0ZSk7XG5cbiAgICAgIC8vIGxvb3AgYWdhaW5cbiAgICAgIGxvb3BJZCA9IGxvb3AodXBkYXRlKTtcbiAgICB9O1xuXG4gICAgLy8gTG9vcFxuICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzZXRQb3NpdGlvbigpICYmIHBhdXNlID09PSBmYWxzZSkge1xuICAgICAgICBhbmltYXRlKCk7XG5cbiAgICAgICAgLy8gbG9vcCBhZ2FpblxuICAgICAgICBsb29wSWQgPSBsb29wKHVwZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb29wSWQgPSBudWxsO1xuXG4gICAgICAgIC8vIERvbid0IGFuaW1hdGUgdW50aWwgd2UgZ2V0IGEgcG9zaXRpb24gdXBkYXRpbmcgZXZlbnRcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGRlZmVycmVkVXBkYXRlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgZGVmZXJyZWRVcGRhdGUpO1xuICAgICAgICAoc2VsZi5vcHRpb25zLndyYXBwZXIgPyBzZWxmLm9wdGlvbnMud3JhcHBlciA6IHdpbmRvdykuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZGVmZXJyZWRVcGRhdGUsIHN1cHBvcnRzUGFzc2l2ZSA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogZmFsc2UpO1xuICAgICAgICAoc2VsZi5vcHRpb25zLndyYXBwZXIgPyBzZWxmLm9wdGlvbnMud3JhcHBlciA6IGRvY3VtZW50KS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBkZWZlcnJlZFVwZGF0ZSwgc3VwcG9ydHNQYXNzaXZlID8geyBwYXNzaXZlOiB0cnVlIH0gOiBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFRyYW5zZm9ybTNkIG9uIHBhcmFsbGF4IGVsZW1lbnRcbiAgICB2YXIgYW5pbWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9ucztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5lbGVtcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIC8vIERldGVybWluZSByZWxldmFudCBtb3ZlbWVudCBkaXJlY3Rpb25zXG4gICAgICAgIHZhciB2ZXJ0aWNhbFNjcm9sbEF4aXMgPSBibG9ja3NbaV0udmVydGljYWxTY3JvbGxBeGlzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBob3Jpem9udGFsU2Nyb2xsQXhpcyA9IGJsb2Nrc1tpXS5ob3Jpem9udGFsU2Nyb2xsQXhpcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgdmVydGljYWxTY3JvbGxYID0gdmVydGljYWxTY3JvbGxBeGlzLmluZGV4T2YoXCJ4XCIpICE9IC0xID8gcG9zWSA6IDA7XG4gICAgICAgIHZhciB2ZXJ0aWNhbFNjcm9sbFkgPSB2ZXJ0aWNhbFNjcm9sbEF4aXMuaW5kZXhPZihcInlcIikgIT0gLTEgPyBwb3NZIDogMDtcbiAgICAgICAgdmFyIGhvcml6b250YWxTY3JvbGxYID0gaG9yaXpvbnRhbFNjcm9sbEF4aXMuaW5kZXhPZihcInhcIikgIT0gLTEgPyBwb3NYIDogMDtcbiAgICAgICAgdmFyIGhvcml6b250YWxTY3JvbGxZID0gaG9yaXpvbnRhbFNjcm9sbEF4aXMuaW5kZXhPZihcInlcIikgIT0gLTEgPyBwb3NYIDogMDtcblxuICAgICAgICB2YXIgcGVyY2VudGFnZVkgPSAoKHZlcnRpY2FsU2Nyb2xsWSArIGhvcml6b250YWxTY3JvbGxZIC0gYmxvY2tzW2ldLnRvcCArIHNjcmVlblkpIC8gKGJsb2Nrc1tpXS5oZWlnaHQgKyBzY3JlZW5ZKSk7XG4gICAgICAgIHZhciBwZXJjZW50YWdlWCA9ICgodmVydGljYWxTY3JvbGxYICsgaG9yaXpvbnRhbFNjcm9sbFggLSBibG9ja3NbaV0ubGVmdCArIHNjcmVlblgpIC8gKGJsb2Nrc1tpXS53aWR0aCArIHNjcmVlblgpKTtcblxuICAgICAgICAvLyBTdWJ0cmFjdGluZyBpbml0aWFsaXplIHZhbHVlLCBzbyBlbGVtZW50IHN0YXlzIGluIHNhbWUgc3BvdCBhcyBIVE1MXG4gICAgICAgIHBvc2l0aW9ucyA9IHVwZGF0ZVBvc2l0aW9uKHBlcmNlbnRhZ2VYLCBwZXJjZW50YWdlWSwgYmxvY2tzW2ldLnNwZWVkLCBibG9ja3NbaV0udmVydGljYWxTcGVlZCwgYmxvY2tzW2ldLmhvcml6b250YWxTcGVlZCk7XG4gICAgICAgIHZhciBwb3NpdGlvblkgPSBwb3NpdGlvbnMueSAtIGJsb2Nrc1tpXS5iYXNlWTtcbiAgICAgICAgdmFyIHBvc2l0aW9uWCA9IHBvc2l0aW9ucy54IC0gYmxvY2tzW2ldLmJhc2VYO1xuXG4gICAgICAgIC8vIFRoZSBuZXh0IHR3byBcImlmXCIgYmxvY2tzIGdvIGxpa2UgdGhpczpcbiAgICAgICAgLy8gQ2hlY2sgaWYgYSBsaW1pdCBpcyBkZWZpbmVkIChmaXJzdCBcIm1pblwiLCB0aGVuIFwibWF4XCIpO1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIGNoYW5nZSB0aGUgWSBvciB0aGUgWFxuICAgICAgICAvLyAoQ3VycmVudGx5IHdvcmtpbmcgb25seSBpZiBqdXN0IG9uZSBvZiB0aGUgYXhlcyBpcyBlbmFibGVkKVxuICAgICAgICAvLyBUaGVuLCBjaGVjayBpZiB0aGUgbmV3IHBvc2l0aW9uIGlzIGluc2lkZSB0aGUgYWxsb3dlZCBsaW1pdFxuICAgICAgICAvLyBJZiBzbywgdXNlIG5ldyBwb3NpdGlvbi4gSWYgbm90LCBzZXQgcG9zaXRpb24gdG8gbGltaXQuXG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgYSBtaW4gbGltaXQgaXMgZGVmaW5lZFxuICAgICAgICBpZiAoYmxvY2tzW2ldLm1pbiAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMudmVydGljYWwgJiYgIXNlbGYub3B0aW9ucy5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICBwb3NpdGlvblkgPSBwb3NpdGlvblkgPD0gYmxvY2tzW2ldLm1pbiA/IGJsb2Nrc1tpXS5taW4gOiBwb3NpdGlvblk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuaG9yaXpvbnRhbCAmJiAhc2VsZi5vcHRpb25zLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICBwb3NpdGlvblggPSBwb3NpdGlvblggPD0gYmxvY2tzW2ldLm1pbiA/IGJsb2Nrc1tpXS5taW4gOiBwb3NpdGlvblg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgZGlyZWN0aW9uYWwgbWluIGxpbWl0cyBhcmUgZGVmaW5lZFxuICAgICAgICBpZiAoYmxvY2tzW2ldLm1pblkgIT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zaXRpb25ZID0gcG9zaXRpb25ZIDw9IGJsb2Nrc1tpXS5taW5ZID8gYmxvY2tzW2ldLm1pblkgOiBwb3NpdGlvblk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2Nrc1tpXS5taW5YICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uWCA9IHBvc2l0aW9uWCA8PSBibG9ja3NbaV0ubWluWCA/IGJsb2Nrc1tpXS5taW5YIDogcG9zaXRpb25YO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgYSBtYXggbGltaXQgaXMgZGVmaW5lZFxuICAgICAgICBpZiAoYmxvY2tzW2ldLm1heCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMudmVydGljYWwgJiYgIXNlbGYub3B0aW9ucy5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICBwb3NpdGlvblkgPSBwb3NpdGlvblkgPj0gYmxvY2tzW2ldLm1heCA/IGJsb2Nrc1tpXS5tYXggOiBwb3NpdGlvblk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuaG9yaXpvbnRhbCAmJiAhc2VsZi5vcHRpb25zLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICBwb3NpdGlvblggPSBwb3NpdGlvblggPj0gYmxvY2tzW2ldLm1heCA/IGJsb2Nrc1tpXS5tYXggOiBwb3NpdGlvblg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgZGlyZWN0aW9uYWwgbWF4IGxpbWl0cyBhcmUgZGVmaW5lZFxuICAgICAgICBpZiAoYmxvY2tzW2ldLm1heFkgIT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zaXRpb25ZID0gcG9zaXRpb25ZID49IGJsb2Nrc1tpXS5tYXhZID8gYmxvY2tzW2ldLm1heFkgOiBwb3NpdGlvblk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2Nrc1tpXS5tYXhYICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uWCA9IHBvc2l0aW9uWCA+PSBibG9ja3NbaV0ubWF4WCA/IGJsb2Nrc1tpXS5tYXhYIDogcG9zaXRpb25YO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHppbmRleCA9IGJsb2Nrc1tpXS56aW5kZXg7XG5cbiAgICAgICAgLy8gTW92ZSB0aGF0IGVsZW1lbnRcbiAgICAgICAgLy8gKFNldCB0aGUgbmV3IHRyYW5zbGF0aW9uIGFuZCBhcHBlbmQgaW5pdGlhbCBpbmxpbmUgdHJhbnNmb3Jtcy4pXG4gICAgICAgIHZhciB0cmFuc2xhdGUgPSAndHJhbnNsYXRlM2QoJyArIChzZWxmLm9wdGlvbnMuaG9yaXpvbnRhbCA/IHBvc2l0aW9uWCA6ICcwJykgKyAncHgsJyArIChzZWxmLm9wdGlvbnMudmVydGljYWwgPyBwb3NpdGlvblkgOiAnMCcpICsgJ3B4LCcgKyB6aW5kZXggKyAncHgpICcgKyBibG9ja3NbaV0udHJhbnNmb3JtO1xuICAgICAgICBzZWxmLmVsZW1zW2ldLnN0eWxlW3RyYW5zZm9ybVByb3BdID0gdHJhbnNsYXRlO1xuICAgICAgfVxuICAgICAgc2VsZi5vcHRpb25zLmNhbGxiYWNrKHBvc2l0aW9ucyk7XG4gICAgfTtcblxuICAgIHNlbGYuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmVsZW1zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgc2VsZi5lbGVtc1tpXS5zdHlsZS5jc3NUZXh0ID0gYmxvY2tzW2ldLnN0eWxlO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgcmVzaXplIGV2ZW50IGxpc3RlbmVyIGlmIG5vdCBwYXVzZSwgYW5kIHBhdXNlXG4gICAgICBpZiAoIXBhdXNlKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbml0KTtcbiAgICAgICAgcGF1c2UgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciB0aGUgYW5pbWF0aW9uIGxvb3AgdG8gcHJldmVudCBwb3NzaWJsZSBtZW1vcnkgbGVha1xuICAgICAgY2xlYXJMb29wKGxvb3BJZCk7XG4gICAgICBsb29wSWQgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBJbml0XG4gICAgaW5pdCgpO1xuXG4gICAgLy8gQWxsb3cgdG8gcmVjYWxjdWxhdGUgdGhlIGluaXRpYWwgdmFsdWVzIHdoZW5ldmVyIHdlIHdhbnRcbiAgICBzZWxmLnJlZnJlc2ggPSBpbml0O1xuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG4gIHJldHVybiBSZWxsYXg7XG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLFdBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/rellax/rellax.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./src/ts/parallax/index.ts":
/*!**********************************!*\
  !*** ./src/ts/parallax/index.ts ***!
  \**********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var rellax__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rellax */ \"./node_modules/rellax/rellax.js\");\n/* harmony import */ var rellax__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rellax__WEBPACK_IMPORTED_MODULE_0__);\n\n\ndocument.onreadystatechange = function () {\n  if (document.readyState === \"complete\" && window.matchMedia(\"(pointer: fine)\").matches && window.matchMedia(\"(min-width: 768px)\").matches && !!document.querySelector(\".rellax\")) {\n    var rellax = new rellax__WEBPACK_IMPORTED_MODULE_0___default.a(\".rellax\", {\n      center: true\n    });\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdHMvcGFyYWxsYXgvaW5kZXgudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdHMvcGFyYWxsYXgvaW5kZXgudHM/OTA2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVsbGF4IGZyb20gXCJyZWxsYXhcIlxuXG5kb2N1bWVudC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gaWYgKFxuICBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgJiZcbiAgd2luZG93Lm1hdGNoTWVkaWEoXCIocG9pbnRlcjogZmluZSlcIikubWF0Y2hlcyAmJlxuICB3aW5kb3cubWF0Y2hNZWRpYShcIihtaW4td2lkdGg6IDc2OHB4KVwiKS5tYXRjaGVzICYmXG4gICEhZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5yZWxsYXhcIilcbiApIHtcbiAgdmFyIHJlbGxheCA9IG5ldyBSZWxsYXgoXCIucmVsbGF4XCIsIHsgY2VudGVyOiB0cnVlIH0pXG4gfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQUE7QUFBQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/ts/parallax/index.ts\n");

/***/ }),

/***/ "./src/ts/services/index.ts":
/*!**********************************!*\
  !*** ./src/ts/services/index.ts ***!
  \**********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parallax__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parallax */ \"./src/ts/parallax/index.ts\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdHMvc2VydmljZXMvaW5kZXgudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdHMvc2VydmljZXMvaW5kZXgudHM/ZjNlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCIuLi9wYXJhbGxheFwiXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/ts/services/index.ts\n");

/***/ })

/******/ });